* General Comments
** Defense
A good starting defense would be just make life as difficult for the symbolic execution engine as possible by patching the binary (in essence jamming)  since a lot of the favored teams will be using this technique.

More classic forms of defense are those that protect from the control flow hijacking in general such as control flow integrity enforcement mechanisms by patching the binary with a system of trampolines. See http://www.cs.sunysb.edu/~mizhang/papers/binCFI.pdf . 

Many teams will be enamored with OCaml and C++ so it might might be worth considering exploiting the tool doing the exploiting since the tool is really just a complicated execution environment that is probably itself very insecure and will assume that the binary is “safe.” This is a very speculative defense so probably the last thing to consider. This type of defense is reminiscent of the many zerodays found in Wireshark and then used during CTFs.

** Attack
Much of this competition will be a special case of a field known as program synthesis. Local buffer overflows are the easiest to get working since the SMT will do most of program extraction (Exploit Generation) for you once you see the buffer-overflow exploit from the verification perspective.
(Need to upload writings on local and non-local exploits (think chained vs not chained) in the context of binaries.) Let's see how this done in practice with the following examples: 

** Delivery
*** ROP
*** JOP
*** Return To Libc    
* Exploits 
** CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')
*** Attack
**** http://users.ece.cmu.edu/~sangkilc/papers/oakland12-cha.pdf
**** Software Crash Analysis for Automatic Exploit Generation on Binary Programs by Shih-Kun Huang, Min-Hsiang Huang, Po-Yen Huang, Han-Lin Lu, and Chung-Wei Lai - https://drive.google.com/file/d/0BymO5h8P3PgAaE8zOVRYZWRCNEE/edit?usp=sharing 
** CWE-121: Stack-based Buffer Overflow
*** Defense
Eliminating Stack Overﬂow by Abstract Interpretation - http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.64.6170&rep=rep1&type=pdf
** CWE-122: Heap-based Buffer Overflow
** CWE-123: Write-what-where Condition
** CWE-124: Buffer Underwrite ('Buffer Underflow')
** CWE-128: Wrap-around Error
** CWE-129: Improper Validation of Array Index
** CWE-130: Improper Handling of Length Parameter Inconsistency
** CWE-131: Incorrect Calculation of Buffer Size
** CWE-134: Uncontrolled Format String
** CWE-135: Incorrect Calculation of Multi-Byte String Length
** CWE-147: Improper Neutralization of Input Terminators
** CWE-158: Improper Neutralization of Null Byte or NUL Character
** CWE-170: Improper Null Termination
** CWE-190: Integer Overflow or Wraparound
** CWE-191: Integer Underflow (Wrap or Wraparound)
*** Attack
Modular Bug-ﬁnding for Integer Overﬂows in the Large: Sound, Efﬁcient, Bit-precise Static Analysis - http://research.microsoft.com/pubs/80722/z3prefix.pdf

UQBTng: a tool capable of automatically finnding integer overows in Win32 binaries - http://events.ccc.de/congress/2005/fahrplan/attachments/552-Paper_AToolCapableOfAutomaticallyFindingIntegerOverflowsInWin32Binaries.pdf

IntScope: Automatically Detecting Integer Overﬂow Vulnerability in X86 Binary Using Symbolic Execution - http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.153.1801&rep=rep1&type=pdf

New Binary System for Detecting and Locating Integer-based Vulnerability on Run-time Type Analysis

Detecting interger flaws by type-qualified system dependence graph

*** Defense
An ‘Explicit Type Enforcement’ Program Transformation Tool for Preventing Integer Vulnerabilities - http://www.munawarhafiz.com/research/intproblem/H11-SplashDemo_AIC.pdf

Program Transformations to Fix C Integers - http://www.munawarhafiz.com/research/intproblem/H11-SplashDemo_AIC.pdf
** CWE-193: Off-by-one Error
** CWE-194: Unexpected Sign Extension
** CWE-195: Signed to Unsigned Conversion Error
** CWE-196: Unsigned to Signed Conversion Error
** CWE-401: Improper Release of Memory Before Removing Last Reference
** CWE-409: Improper Handling of Highly Compressed Data (Data Amplification)
** CWE-415: Double Free
** CWE-416: Use After Free
*** Attack
**** http://grehack.org/files/2013/talks/talk_3_4_Feist_-_Statically_Detecting_Use_After_Free_on_Binary_Code-grehack.pdf
**** http://grehack.org/files/2013/GreHack_2013_proceedings-separate_files/3-accepted_papers/3.4_Feist_-_Statically_Detecting_Use_After_Free_on_Binary_Code.pdf
** CWE-457: Use of Uninitialized Variable
** CWE-466: Return of pointer value outside of expected range
** CWE-467: Use of sizeof() on a Pointer Type
** CWE-468: Incorrect Pointer Scaling
** CWE-469: Use of Pointer Subtraction to Determine Size
** CWE-763: Release of Invalid Pointer or Reference WE-786: Access of Memory Location Before Start of Buffer
** CWE-787: Out-of-bounds Write
** CWE-788: Access of Memory Location After End of Buffer
** CWE-805: Buffer Access with Incorrect Length Value
** CWE-806: Buffer Access Using Size of Source Buffer
** CWE-822: Untrusted Pointer Dereference
** CWE-823: Use of Out-of-range Pointer Offset
** CWE-824: Access of Uninitialized Pointer
** CWE-825: Expired Pointer Dereference
